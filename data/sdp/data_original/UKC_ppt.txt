'适配器模式':刘 伟第10章 适配器模式设计模式（第2版）大 纲123模式动机与定义模式结构与分析模式实例与解析4模式效果与应用 模式动机 电源适配器 模式动机 现实生活： 不兼容：生活用电220V  笔记电脑20V 引入 AC Adapter（交流电适配器） 软件开发： 存在不兼容的结构，例如方法名不一致 引入适配器模式 模式定义 适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。 适配器模式既可以作为类结构型模式，也可以作为对象结构型模式 定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合 模式结构 类适配器 模式结构 对象适配器 模式结构 适配器模式包含如下角色： Target：目标抽象类 Adapter：适配器类 Adaptee：适配者类 模式分析 典型的类适配器示例代码： 模式分析 典型的对象适配器示例代码： 模式实例 仿生机器人：实例说明 现需要设计一个可以模拟各种动物行为的机器人，在机器人中定义了一系列方法，如机器人叫喊方法cry()、机器人移动方法move()等。如果希望在不修改已有代码的基础上使得机器人能够像狗一样叫，像狗一样跑，使用适配器模式进行系统设计。 模式实例 仿生机器人：参考类图 模式实例 仿生机器人：参考代码 DesignPatterns之adapter包 适配器模式优点： 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构 增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用 灵活性和扩展性非常好 类适配器模式：置换一些适配者的方法很方便 对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类 适配器模式缺点： 类适配器模式： (1) 一次最多只能适配一个适配者类，不能同时适配多个适配者 (2) 适配者类不能为最终类 (3) 目标抽象类只能为接口，不能为类 对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦
'抽象工厂模式':刘 伟第6章 抽象工厂模式设计模式（第2版）大 纲123模式动机与定义模式结构与分析模式实例与解析4模式效果与应用 模式动机 产品等级结构：产品等级结构即产品的继承结构，例如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 模式动机 产品族与产品等级结构示意图 模式定义 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 模式定义 抽象工厂模式示意图 模式结构 模式结构 抽象工厂模式包含如下角色： AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 ConcreteProduct：具体产品 模式分析 模式分析 模式分析 模式实例 电器工厂：实例说明 一个电器工厂可以产生多种类型的电器，如海尔工厂可以生产海尔电视机、海尔空调等，TCL工厂可以生产TCL电视机、TCL空调等，相同品牌的电器构成一个产品族，而相同类型的电器构成了一个产品等级结构，现使用抽象工厂模式模拟该场景。 模式实例 电器工厂：参考类图 模式实例 电器工厂：参考代码 DesignPatterns之abstractfactory包 抽象工厂模式优点： 隔离了具体类的生成，使得客户端并不需要知道什么被创建 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象 增加新的产品族很方便，无须修改已有系统，符合开闭原则 抽象工厂模式缺点： 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则
'命令模式':刘 伟第18章 命令模式设计模式（第2版）大 纲123模式动机与定义模式结构与分析模式实例与解析4模式效果与应用 模式动机 开关与电灯、排气扇示意图 模式动机 现实生活 相同的开关可以通过不同的电线来控制不同的电器 开关   请求发送者 电灯   请求的最终接收者和处理者 开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者 模式动机 软件开发 按钮   请求发送者 事件处理类   请求的最终接收者和处理者 发送者与接收者之间引入了新的命令对象（类似电线），将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法 相同的按钮可以对应不同的事件处理类 模式定义 命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。 命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式 模式结构 模式结构 命令模式包含如下角色： Command: 抽象命令类 ConcreteCommand: 具体命令类 Invoker: 调用者 Receiver: 接收者 模式分析 将请求发送者和接收者完全解耦 发送者与接收者之间没有直接引用关系 发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求 命令模式的本质是对请求进行封装 一个请求对应于一个命令，将发出命令的责任和执行命令的责任分开 模式分析 调用者（请求发送者）示例代码： 模式分析 具体命令类示例代码： 模式分析 宏命令 模式实例 电视机遥控器：实例说明 电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。显然，电视机遥控器就是一个典型的命令模式应用实例。 模式实例 电视机遥控器：参考类图 模式实例 电视机遥控器：参考代码 DesignPatterns之command包 命令模式优点： 降低系统的耦合度 新的命令可以很容易地加入到系统中，符合开闭原则 可以比较容易地设计一个命令队列或宏命令（组合命令） 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案 命令模式缺点： 使用命令模式可能会导致某些系统有过多的具体命令类（针对每一个对请求接收者的调用操作都需要设计一个具体命令类） 在以下情况下可以使用命令模式： 需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互 需要在不同的时间指定请求、将请求排队和执行请求 需要支持命令的撤销(Undo)操作和恢复(Redo)操作 需要将一组操作组合在一起形成宏命令
