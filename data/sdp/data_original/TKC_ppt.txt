'策略模式':刘 伟第25章 策略模式设计模式（第2版）大 纲123模式动机与定义模式结构与分析模式实例与解析4模式效果与应用 模式动机 旅游出行方式示意图 模式动机 实现某个目标的途径不止一条，可根据实际情况选择一条合适的途径 软件开发： 多种算法，例如排序、查找、打折等 使用硬编码(Hard Coding)实现将导致系统违背开闭原则，扩展性差，且维护困难 可以定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法  策略类  策略模式 模式定义 策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。 策略模式让算法独立于使用它的客户而变化 策略模式是一种对象行为型模式 模式结构 模式结构 策略模式包含如下角色： Context: 环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 模式分析 每一个封装算法的类称之为策略(Strategy)类 策略模式提供了一种可插入式(Pluggable)算法的实现方案 环境类示例代码： 模式实例 排序策略：实例说明 某系统提供了一个用于对数组数据进行操作的类，该类封装了对数组的常见操作，如查找数组元素、对数组元素进行排序等。现以排序操作为例，使用策略模式设计该数组操作类，使得客户端可以动态地更换排序算法，可以根据需要选择冒泡排序或选择排序或插入排序，也能够灵活地增加新的排序算法。 模式实例 排序策略：参考类图 模式实例 排序策略：参考代码 DesignPatterns之strategy包 策略模式优点： 提供了对开闭原则的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为 提供了管理相关的算法族的办法 提供了一种可以替换继承关系的办法 可以避免多重条件选择语句 提供了一种算法的复用机制，不同的环境类可以方便地复用策略类 策略模式缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类 将造成系统产生很多具体策略类 无法同时在客户端使用多个策略类
'装饰模式':大 纲123模式动机与定义模式结构与分析模式实例与解析4模式效果与应用 模式动机 相片框 模式动机 可以在不改变一个对象本身功能的基础上给对象增加额外的新行为 是一种用于替代继承的技术，它通过一种无须定义子类的方式给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系 引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩展原有类的功能 模式定义 装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活 对象结构型模式 以对客户透明的方式动态地给一个对象附加上更多的责任 可以在不需要创建更多子类的情况下，让对象的功能得以扩展 模式结构 模式结构 装饰模式包含如下角色： Component: 抽象构件类 ConcreteComponent: 具体构件类 Decorator: 抽象装饰类 ConcreteDecorator: 具体装饰类 模式分析 抽象装饰类示例代码： 模式分析 具体装饰类示例代码： 模式分析 透明装饰模式 透明(Transparent)装饰模式：要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型 对于客户端而言，具体构件对象和具体装饰对象没有任何区别 可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别 可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象 无法在客户端单独调用新增方法addedBehavior() 模式分析 透明装饰模式 模式分析 不透明装饰模式 半透明(Semi-transparent)装饰模式：用具体装饰类型来定义装饰之后的对象，而具体构件使用抽象构件类型来定义 对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的 可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便 客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用addedBehavior()方法 最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象 模式分析 不透明装饰模式 模式实例 变形金刚：实例说明 变形金刚在变形之前是一辆汽车，它可以在陆地上移动。当它变成机器人之后除了能够在陆地上移动之外，还可以说话；如果需要，它还可以变成飞机，除了在陆地上移动还可以在天空中飞翔。 模式实例 变形金刚：参考类图 模式实例 变形金刚：参考代码 DesignPatterns之decorator包 装饰模式优点： 对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为 可以对一个对象进行多次装饰 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，且原有类库代码无须改变，符合开闭原则 装饰模式缺点： 使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必会占用更多的系统资源，在一定程度上影响程序的性能 比继承更加易于出错，排错也更困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐
'UML类图':大 纲1UML概述2类图UMLUnified Modeling Language统一建模语言统一建模语言统一建模语言 UML是一个通用的可视化建模语言，不同于编程语言，它通过一些标准的图形符号和文字来对系统进行建模 用于对软件进行描述、可视化处理、构建软件系统的文档 是一套总结了以往建模技术的经验并吸收了当今最优秀成果的标准建模方法 UML的结构 视图(View) 用户视图：以用户的观点表示系统的目标，它是所有视图的核心，该视图描述系统的需求 结构视图：表示系统的静态行为，描述系统的静态元素，如包、类与对象，以及它们之间的关系 行为视图：表示系统的动态行为，描述系统的组成元素如对象在系统运行时的交互关系 实现视图：表示系统中逻辑元素的分布，描述系统中的文件以及它们之间的关系 环境视图：表示系统中物理元素的分布，描述系统中的硬件设备以及它们之间的关系 UML的结构 图(Diagram) 用例图(Use Case Diagram) 类图(Class Diagram)，对象图(Object Diagram)，包图(Package Diagram)，组合结构图(Composite Structure Diagram) 状态图(State Diagram)，活动图(Activity Diagram)，顺序图(Sequence Diagram)，通信图(Communication Diagram)，定时图(Timing Diagram)，交互概览图(Interaction Overview Diagram) 组件图(Component Diagram) 部署图(Deployment Diagram) UML的结构 模型元素(Model Element) 模型元素包括事物以及事物与事物之间的关系 事物是UML的重要组成部分，它代表任何可以定义的东西 事物之间的关系把事物联系在一起，组成有意义的结构模型 每一个模型元素都有一个与之相对应的图形元素 同一个模型元素可以在不同的UML图中使用 但无论在哪个图中，同一个模型元素都保持相同的意义和符号
'Java权限修饰符':UML的结构 通用机制(General Mechanism) UML提供的通用机制为模型元素提供额外的注释、语义和其他信息，包括扩展机制，允许用户对UML进行扩展 类与类图 类(Class)封装了数据和行为，是面向对象的重要组成部分 类是具有相同属性、操作、关系的对象集合的总称 在系统中，每个类具有一定的职责，职责指的是类所担任的任务，即类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计得好的类一般只有一种职责 类的属性即类的数据职责，类的操作即类的行为职责 类图(Class Diagram)使用出现在系统中的不同类来描述系统的静态结构，它用来描述不同的类以及它们之间的关系 类的UML图示 在UML类图中，类一般由三部分组成： 第一部分是类名：每个类都必须有一个名字，类名是一个字符串 按照Java语言的命名规范，类名中每一个单词的首字母均大写 public class Employee { private String name; private int age; private String email; public void modifyInfo() { ...... } } 类的UML图示 在UML类图中，类一般由三部分组成： 第二部分是类的属性(Attributes)：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性 按照Java语言的命名规范，属性名中的第一个单词全小写，之后每个单词首字母大写（驼峰命名法） 类的UML图示 在UML类图中，类一般由三部分组成： 第三部分是类的操作(Operations)：操作是类的任意一个实例对象都拥有的行为，是类的成员方法 按照Java语言的命名规范，方法名中的第一个单词全小写，之后每个单词首字母大写（驼峰命名法） 类之间的关系 关联关系 关联(Association)关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系 在UML类图中，用实线连接有关联关系的对象所对应的类，在使用Java、C++和C#等编程语言实现关联关系时，通常将一个类的对象作为另一个类的成员变量 在使用类图表示关联关系时可以在关联线上标注角色名 类之间的关系 关联关系 类之间的关系 关联关系 双向关联 类之间的关系 关联关系 单向关联 类之间的关系 关联关系 自关联 类之间的关系 关联关系 多重性关联 ：多重性关联关系又称为重数性(Multiplicity)关联关系，表示两个关联对象在数量上的对应关系。在UML中，对象之间的多重性可以直接在关联直线上用一个数字或一个数字范围表示 类之间的关系 关联关系 多重性关联 类之间的关系 关联关系 聚合关联 聚合(Aggregation)关系表示整体与部分的关系 在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在 在UML中，聚合关系用带空心菱形的直线表示 类之间的关系 关联关系 聚合关联 类之间的关系 关联关系 组合关联 组合(Composition)关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在 成员对象与整体对象之间具有同生共死的关系 在UML中，组合关系用带实心菱形的直线表示 类之间的关系 关联关系 组合关联 类之间的关系 依赖关系 依赖(Dependency)关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系 大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数 在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方 类之间的关系 依赖关系 类之间的关系 依赖关系 在系统实现阶段，依赖关系通常通过三种方式来实现： 将一个类的对象作为另一个类中方法的参数 在一个类的方法中将另一个类的对象作为其局部变量 在一个类的方法中调用另一个类的静态方法 类之间的关系 泛化关系 泛化(Generalization)关系也就是继承关系，用于描述父类与子类之间的关系，父类又称为基类或超类，子类又称为派生类 在UML中，泛化关系用带空心三角形的直线来表示 在代码实现时，使用面向对象的继承机制来实现泛化关系，在Java语言中使用extends关键字、在C++/C#中使用冒号“：”来实现 类之间的关系 泛化关系 类之间的关系 接口与实现关系 接口之间也可以有与类之间关系类似的继承关系和依赖关系 接口和类之间存在一种实现(Realization)关系，在这种关系中，类实现了接口，类中的操作实现了接口中声明的操作 在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示 类之间的关系 接口与实现关系 注释
'客户/服务器风格、浏览器/服务器风格':本课时学习重点B/S结构与三层结构 HTTP请求响应机制 Web应用程序的结构和思想 Web.xml文件简介 创建并部署Web应用程序 聚慕课教育研发中心学习、授课与教学PPT课件B/S结构与三层结构B/S结构（Browser/Server，浏览器/服务器模式），是WEB兴起后的一种网络结构模式，WEB浏览器是客户端最主要的应用软件。 微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层。聚慕课教育研发中心学习、授课与教学PPT课件
'分层风格':本课时学习重点理解DAO开发模式的原理 理解MVC开发模式的原理 掌握使用DAO设计模式，并能够熟练使用进行程序开发 掌握使用MVC设计模式，并能够熟练使用进行程序开发 了解当下主流的框架 聚慕课教育研发中心学习、授课与教学PPT课件DAO设计模式DAO简介 DAO各部分详解 DBC与DAO 聚慕课教育研发中心学习、授课与教学PPT课件硬件条件DAO（Data Access Object,数据访问对象），既然是数据访问对象，由此不难发现DAO的主要功能就是操作数据库的，也就是数据的增删改查。所以DAO在标准的开发架构中属于数据层。 接下来分别介绍每一层的功能。 客户层：目前采用B/S开发架构居多，客户使用浏览器访问，当然也可以使用别的工具访问。 显示层：使用JSP/Servlet进行页面显示。 业务层：负责将DAO层的操作进行组合，形成一个完整的业务逻辑。 数据层：提供原子性操作，比如增加、删除、修改、查询。 聚慕课教育研发中心学习、授课与教学PPT课件DAO各部分详解DAO的设计流程（包括以下六个部分）： 1、DatabaseConnection。 设计一个专门负责打开连接数据库和关闭数据库操作的类。 命名规则：xxx.dbc.DatabaseConnection。 2、VO。 设计VO（值对象）,其主要有属性和setter和getter方法构成，以数据库中的字段项对应。 命名规则：xxx.vo.ttt；ttt要与数据库的表的名字一致。 3、DAO。 定义一系列的原子性操作，如增删改查等操作的接口。 命名规则：xxx.dao.IXxx.DAO。 4、Impl。 设计DAO接口的真正实现的类，完成具体的数据库操作。但是不再去负责数据库的打开和关闭。 命名规则：xxx.dao.impl.xxxDAOImpl。 5、Proxy。 Proxy代理类的实现：主要将以上四部分合起来，完成整个操作过程。 命名规则：xxx.dao.proxy.XxxProxy。 6、Factory。 Factory类主要用来获得一个DAO类的实例对象。 命名规则：xxx.factory.DAOFactory。 聚慕课教育研发中心学习、授课与教学PPT课件
'面向对象设计原则简介':刘 伟第2章 面向对象设计原则设计模式（第2版）大 纲1面向对象设计原则概述2单一职责原则3开闭原则4里氏代换原则5678依赖倒转原则接口隔离原则合成复用原则迪米特法则 可维护性(Maintainability)：指软件能够被理解、改正、适应及扩展的难易程度 可复用性(Reusability)：指软件能够被重复使用的难易程度 面向对象设计的目标之一在于支持可维护性复用，一方面需要实现设计方案或者源代码的复用，另一方面要确保系统能够易于扩展和修改，具有良好的可维护性 Robert C.Martin 面向对象设计原则为支持可维护性复用而诞生 指导性原则，非强制性原则 每一个设计模式都符合一个或多个面向对象设计原则，面向对象设计原则是用于评价一个设计模式的使用效果的重要指标之一 单一职责原则定义 单一职责原则是最简单的面向对象设计原则，用于控制类的粒度大小 就一个类而言，应该仅有一个引起它变化的原因 There should never be more than one reason for a class to change. 单一职责原则分析 一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小 当一个职责变化时，可能会影响其他职责的运作 将这些职责进行分离，将不同的职责封装在不同的类中 将不同的变化原因封装在不同的类中 单一职责原则是实现高内聚、低耦合的指导方针 单一职责原则实例 实例说明 某基于Java的C/S系统的“登录功能”通过如下登录类(Login)实现： 现使用单一职责原则对其进行重构。 单一职责原则实例 实例解析 开闭原则定义 开闭原则是面向对象的可复用设计的第一块基石，是最重要的面向对象设计原则 开闭原则分析 开闭原则由Bertrand Meyer于1988年提出 在开闭原则的定义中，软件实体可以是一个软件模块、一个由多个类组成的局部结构或一个独立的类 开闭原则是指软件实体应尽量在不修改原有代码的情况下进行扩展 开闭原则分析 抽象化是开闭原则的关键 相对稳定的抽象层 + 灵活的具体层 对可变性封装原则(Principle of Encapsulation of Variation, EVP)：找到系统的可变因素并将其封装起来 开闭原则实例 实例说明 某图形界面系统提供了各种不同形状的按钮，客户端代码可针对这些按钮进行编程，用户可能会改变需求要求使用不同的按钮，原始设计方案如图所示： 现对该系统进行重构，使之满足开闭原则的要求。 开闭原则实例 实例解析 里氏代换原则定义 里氏代换原则分析 里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士、麻省理工学院教授Barbara Liskov和卡内基.梅隆大学Jeannette Wing教授于1994年提出 芭芭拉·利斯科夫（Barbara Liskov），美国计算机科学家，2008年图灵奖得主，2004年约翰.冯诺依曼奖得主，美国工程院院士，美国艺术与科学院院士，美国计算机协会会士。现任麻省理工学院电子电气与计算机科学系教授，她是美国第一个计算机科学女博士。 里氏代换原则分析 在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常 反过来则不一定成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象 在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型 里氏代换原则实例 实例说明 某系统需要实现对重要数据（如用户密码）的加密处理，在数据操作类(DataOperator)中需要调用加密类中定义的加密算法，系统提供了两个不同的加密类，CipherA和CipherB，它们实现不同的加密方法，在DataOperator中可以选择其中的一个实现加密操作。如图所示： 里氏代换原则实例 实例说明 如果需要更换一个加密算法类或者增加并使用一个新的加密算法类，如将CipherA改为CipherB，则需要修改客户类Client和数据操作类DataOperator的源代码，违背了开闭原则。 现使用里氏代换原则对其进行重构，使得系统可以灵活扩展，符合开闭原则。 里氏代换原则实例 实例解析 依赖倒转原则定义 要针对接口编程，不要针对实现编程 Program to an interface, not an implementation. 依赖倒转原则分析 依赖倒转原则是Robert C. Martin在1996年为“C++ Reporter”所写的专栏Engineering Notebook的第三篇，后来加入到他在2002年出版的经典著作《Agile Software Development, Principles, Patterns, and Practices》一书中 依赖倒转原则分析 在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等 在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中 针对抽象层编程，将具体类的对象通过依赖注入(Dependency Injection, DI)的方式注入到其他对象 构造注入 设值注入（Setter注入） 接口注入 依赖倒转原则实例 实例说明 某系统提供一个数据转换模块，可以将来自不同数据源的数据转换成多种格式，如可以转换来自数据库的数据(DatabaseSource)、也可以转换来自文本文件的数据(TextSource)，转换后的格式可以是XML文件(XMLTransformer)、也可以是XLS文件(XLSTransformer)等。 依赖倒转原则实例 实例说明 由于需求的变化，该系统可能需要增加新的数据源或者新的文件格式，每增加一个新的类型的数据源或者新的类型的文件格式，客户类MainClass都需要修改源代码，以便使用新的类，但违背了开闭原则。现使用依赖倒转原则对其进行重构。 依赖倒转原则实例 实例解析 接口隔离原则定义 接口隔离原则分析 当一个接口太大时，需要将它分割成一些更细小的接口 使用该接口的客户端仅需知道与之相关的方法即可 每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干 接口隔离原则分析 “接口”定义(1)：一个类型所提供的所有方法特征的集合。一个接口代表一个角色，每个角色都有它特定的一个接口，“角色隔离原则” “接口”定义(2)：狭义的特定语言的接口。接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口，每个接口中只包含一个客户端所需的方法，“定制服务” 接口隔离原则实例 实例说明 下图展示了一个拥有多个客户类的系统，在系统中定义了一个巨大的接口（胖接口）AbstractService来服务所有的客户类。可以使用接口隔离原则对其进行重构。 接口隔离原则实例 实例解析 合成复用原则定义 合成复用原则又称为组合/聚合复用原则(Composition/ Aggregate Reuse Principle, CARP) 合成复用原则分析 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分 新对象通过委派调用已有对象的方法达到复用功能的目的 复用时要尽量使用组合/聚合关系（关联关系），少用继承 合成复用原则分析 继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用 ） 组合/聚合复用：耦合度相对较低，有选择性地调用成员对象的操作；可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。（“黑箱”复用 ） 合成复用原则实例 实例说明 某教学管理系统部分数据库访问类设计如图所示： 合成复用原则实例 实例说明 如果需要更换数据库连接方式，如原来采用JDBC连接数据库，现在采用数据库连接池连接，则需要修改DBUtil类源代码。如果StudentDAO采用JDBC连接，但是TeacherDAO采用连接池连接，则需要增加一个新的DBUtil类，并修改StudentDAO或TeacherDAO的源代码，使之继承新的数据库连接类，这将违背开闭原则，系统扩展性较差。 现使用合成复用原则对其进行重构。 合成复用原则实例 实例解析 迪米特法则定义 迪米特法则又称为最少知识原则(Least Knowledge Principle, LKP) 迪米特法则分析 迪米特法则来自于1987年美国东北大学(Northeastern University)一个名为“Demeter”的研究项目 迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用 应用迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系 迪米特法则分析 迪米特法则要求在设计系统时，应该尽量减少对象之间的交互 如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的相互作用 如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用 通过引入一个合理的“第三者”（中间类）来降低现有对象之间的耦合度 迪米特法则实例 实例说明 某系统界面类(如Form1、Form2等类)与数据访问类(如DAO1、DAO2等类)之间的调用关系较为复杂，如图所示：
'依赖倒转原则分析':依赖倒转原则定义 要针对接口编程，不要针对实现编程 Program to an interface, not an implementation. 依赖倒转原则分析 依赖倒转原则是Robert C. Martin在1996年为“C++ Reporter”所写的专栏Engineering Notebook的第三篇，后来加入到他在2002年出版的经典著作《Agile Software Development, Principles, Patterns, and Practices》一书中 依赖倒转原则分析 在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等 在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中 针对抽象层编程，将具体类的对象通过依赖注入(Dependency Injection, DI)的方式注入到其他对象 构造注入 设值注入（Setter注入） 接口注入 依赖倒转原则实例 实例说明 某系统提供一个数据转换模块，可以将来自不同数据源的数据转换成多种格式，如可以转换来自数据库的数据(DatabaseSource)、也可以转换来自文本文件的数据(TextSource)，转换后的格式可以是XML文件(XMLTransformer)、也可以是XLS文件(XLSTransformer)等。 依赖倒转原则实例 实例说明 由于需求的变化，该系统可能需要增加新的数据源或者新的文件格式，每增加一个新的类型的数据源或者新的类型的文件格式，客户类MainClass都需要修改源代码，以便使用新的类，但违背了开闭原则。现使用依赖倒转原则对其进行重构。 依赖倒转原则实例 实例解析
'单例模式':刘 伟第9章 单例模式设计模式（第2版）大 纲123模式动机与定义模式结构与分析模式实例与解析4模式效果与应用 模式动机 Windows任务管理器在正常情况下只能打开唯一一个任务管理器！ 模式动机 如何确保一个类只有一个实例并且这个实例易于被访问？ 让类自身负责创建和保存它的唯一实例，并保证不能创建其他实例，并且提供一个访问该实例的方法单例模式 模式定义 单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个： 某个类只能有一个实例 必须自行创建这个实例 必须自行向整个系统提供这个实例 单例模式是一种对象创建型模式 模式结构 模式结构 单例模式包含如下角色： Singleton：单例 模式分析 单例模式的实现 私有构造函数 静态私有成员变量（自身类型） 静态公有的工厂方法 模式分析 饿汉式单例类(Eager Singleton) 模式分析 饿汉式单例类(Eager Singleton) 模式分析 懒汉式单例类与双重检查锁定 懒汉式单例类(Lazy Singleton) 模式分析 懒汉式单例类与双重检查锁定 延迟加载 需要较长时间多个线程同时访问将导致创建多个单例对象！怎么办？ 模式分析 懒汉式单例类与双重检查锁定 延迟加载 锁方法 模式分析 懒汉式单例类与双重检查锁定 延迟加载 锁代码段 模式分析 懒汉式单例类与双重检查锁定 延迟加载 模式分析 饿汉式单例类与懒汉式单例类的比较 饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长 懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响 模式分析 使用静态内部类实现单例模式 Java语言中最好的实现方式 Initialization on Demand Holder (IoDH): 使用静态内部类(static inner class) 模式实例 打印池：实例说明 在操作系统中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计。 模式实例 打印池：参考类图 模式实例 打印池：参考代码 DesignPatterns之singleton包 单例模式优点： 提供了对唯一实例的受控访问 可以节约系统资源，提高系统的性能 允许可变数目的实例（多例类） 单例模式缺点： 扩展困难（缺少抽象层） 单例类的职责过重 由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失
'工厂方法模式':刘 伟第5章 工厂方法模式设计模式（第2版）大 纲123模式动机与定义模式结构与分析模式实例与解析4模式效果与应用 模式动机 简单工厂模式工厂方法模式 模式定义 工厂方法模式(Factory Method Pattern)简称工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。 在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 模式结构 模式结构 工厂方法模式包含如下角色： Product：抽象产品 ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂 模式分析 工厂方法模式是简单工厂模式的进一步抽象和推广 工厂方法模式保持了简单工厂模式的优点，并克服了它的缺点 核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给其子类去完成 可以允许系统在不修改工厂角色的情况下引进新产品 增加具体产品-->增加具体工厂，符合“开闭原则” 模式分析 Java反射(Java Reflection)机制的应用 模式分析 配置文件的应用 模式分析 工具类XMLUtil代码片段 模式实例 电视机工厂：实例说明 将原有的电视机工厂进行分割，为每种品牌的电视机提供一个子工厂，海尔工厂专门负责生产海尔电视机，海信工厂专门负责生产海信电视机，如果需要生产TCL电视机或创维电视机，只需要对应增加一个新的TCL工厂或创维工厂即可，原有的工厂无须做任何修改，使得整个系统具有更加的灵活性和可扩展性。 模式实例 电视机工厂：参考类图 模式实例 电视机工厂：参考代码 DesignPatterns之factorymethod包 工厂方法模式优点： 工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节 能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部 在系统中加入新产品时，完全符合开闭原则 工厂方法模式缺点： 系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销 增加了系统的抽象性和理解难度
